1st weeks:
   一、对象的导论
   1.抽象的过程：我们所能够解决问题的复杂性取决于抽象的类型和质量。
   抽象的类型：是指抽象的是什么。

   2.面向对象语言的五个特征：
   1） 万物皆对象、程序是对象的集合他们通过发送消息彼此相关联
   2）每个对象都具有自己的由其他对象所构成的所构成的存储、
   3）每个对象都拥有其类型、
   4）某一特定类型的所有对象都可以接受同样的消息

   2.1面向对象五个原则
   单一职责院子
   依赖倒置

   我所理解的面向对象是继承、封装、多态这三大特征、不知道书中为什么列出的是这五大特征，
我想等以后编码水平提高了才能进一步理解书中的这几句话吧。

   3.复用的具体实现：
   1）最简单的复用某个类的方式是直接使用类的一个对象，将一个类的对象置于一个新的类中，
   被称之为创建"成员对象"
   2）任意类型的其他对象组合成新类想要的功能被称之为组合，如果组合是
   动态发生的，我们称之为"聚合"。组合是 has-a的关系
   3）组合中新类成员中的成员对象通常被声明为private

   4.继承：当创建完一个新类的时候，即使另一个新类与其具有相同的功能，还是创建一个新的类，
   以现有类为基础复制他、然后通过添加和修改这个副本来创建新的类
   类型不仅仅是描述作用一个对象集合的约束条件、同时还有与其他类型之间的关系。
   两个类型可以有相同的特性和行为，其中一个类型可能比另一个含有更多特性。
   继承使用基类和导出类的概念表示了这种类型之间的相似性。
   一个基类包含导出类的所共享的特性和行为。

   5.单根继承：
   在单根继承结构中的所有对象都具有一个公共接口，他们归根到底都是相同的基本类型。
   单根继承保证所有对象都具有某些功能。

   二、一切都是对象
   1.用引用操作对象
   操作标识符实际上是一个对象的引用，引用和对象的关系就如电视和遥控器的关系。
   String s 这里只是引用不是对象。
   一单创建一个引用就希望他与一个新的对象相关联，用关键字new来实现与新的对象相关联。
   
   2.存储到什么地方
   1）寄存器：是最快的存储区域位于处理器的内部，无法进行操控
   2）堆栈：位于Ram中，若堆栈的指针向下移动分配新的内存，向上移动则释放内存，对象的引用
   存储在堆栈当中。
   3)当需要一个对象时。用new写一行简单的代码执行代码会自动在堆里分配内存。
   4）常量存储：常量值通常存放在代码内部，这样做是安全的因为他永远不会改变，可以选择将
   常量存储在rom中
    
   2 weeks:
      1.接口的本质：
      对象可以看作是某种数据类型，但是并不能反映出对象以及操作对象的本质。
      我们实际关心的不是对象的类型，而是对象的能力。
      比如：计算一组数字 我们不关心是用计算器计算还是算盘，关心的是对象计算的能力。

      1）所以类型并不重要，重要的是能力，接口就可以用来表示能力。

      2）接口声明了一组能力，但自身并没有实现这个能力，它只是作为一种约定。

      3）接口涉及交互两方对象，一方需要实现这个接口，另一方需要使用这个接口，对象之间
      并不互相依赖，它们只是通过接口进行交互。

      4）类实现接口，表示类的对象具有接口所表示的能力。

      5）接口重要的地方在于它降低了耦合提高了灵活性。使用接口的代码依赖的是接口本身，而非接口的具体类型。
      程序完全可以根据情况替换接口的实现，而不影响接口使用者，
      6)解决复杂问题的关键是分而治之，将复杂的大问题分解为小问题，分解的核心就是要降低耦合。
       
      2.接口的细节
      1）接口中可以定义变量，例如：
      public interface Interface1{
         public static final int a = 0;
      }
      变量可以通过接口名 Interface1.a来使用

      2）接口也可以继承
      与类不同的是，接口可以有多个父接口

      总结：针对接口不仅可以复用代码也可以降低耦合提高代码的灵活性

      3.抽象类
      1）抽象是相对于具体而言，具体类有直接相应的对象，而抽象类没有。
      2）抽象方法也只有声明并没有实现
      3）抽象类不能创建对象，要创建对象必须使用它的具体字类。
      例如：
     Shape shape = new Circle();
     Shape 是类型Shape类型的变量，引用了具体字类Circle的对象。

     4.为什么需要抽象类
     1）在编写程序时每个人都可能会犯错，减少错误不能依赖个人的优秀素质
     还需要一些机制，使得一个普通人都把容易得事做对，而难以把事情做错。
     抽象类引导使用者正确使用它们，减少误用，使用抽象方法而非空方法体。
     使用抽象类，类的使用者创建对象的时候必须要使用某个具体的字类，而不可能误用不完整的父类。


     5.设计模式
     1.工厂模式
     在任何需要生成复杂对象的地方，都可以使用工厂模式。一个调用者想知道对象
     只要知道名称就可以了，如果想增加一个产品，只要扩展一个工厂类就可以了，
     屏蔽具体实现，调用者只关心产品接口
     2.抽象工厂模式
     在一个产品族里面定义多个产品，在一个工厂里聚合多个同类产品

     3 weeks:
     1.JAVA中的多重继承
     1）接口不仅仅是一种更纯粹的抽象类，它的目标比这个要更高，接口是没有任何具体实现的，
     没有与任何接口相关的存储，也就无法阻止多个接口的组合，组合多个类的接口行为被
     称作为多重继承，
     2）通过继承里扩展接口
     2.通过继承来扩展接口
     通过继承可以很容易地在接口中添加新的方法声明，还可以通过继承在新的接口中组合
     数个接口。
     interface Monster{
        void meance();
     }
     interface dangerousMonster extends Monster{
        void destory();
     }
     interface Lehal{
        void kill ();
     }
     class DragonZilla implements DangerousMonster{
        public void meance(){

        }
        public void destory{

        }
     }
     3.适配接口
     1）接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现
     可以用任何你想要的对象来调用我的方法，只要你的对象调用我的接口。”
     2）java中接口的适配模式
     当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，
     因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题
     ，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，
     实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，
     所以我们写一个类，继承该抽象类，重写我们需要的方法就行

     4）接口与工厂
     接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法
     设计模式
      4 weeks:
     面向对象五大原则
     1.单一职责原则
     最近写代码发现，虽然功能实现了，但是代码的设计是一团糟，耦合性特别强，
     有太多冗余的代码，结构也不够清晰，于是就研读一下设计模式，研读设计模式之前，
     开篇先讲了面向对象五大原则，看完之后，也深有感悟。
     单一原则的定义是：应该有且只有一个原因引起类的变更。
     单一职责原则的好处：
     1）可以降低类的复杂性，实现什么职责都有清洗明确的定义。
     2）增加了代码的可读性，更加容易维护
     3）变更引起的风险降低，如果一个接口的单一职责做得好，一个接口只对响应的
     实现类有影响，这对系统的扩展性，维护性都有很大帮助。
     总结：单一职责原则提出了一个编写代程序的标准，来衡量接口或类设计的是否优良。
     所以在代码设计的时候，接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

     2里氏替换原则
     一般优秀的语言机制有如下的特点：
     1）代码共享，减少创建类的工作量，每个字类都有父类的方法和属性。
     2）提高代码的重用性
     3）提高代码的可扩展性
     4)提高代产品或项目的开放性
     继承的缺点给我最大的感受就是：
     1）继承有很大的侵入性，只要继承就必须有父类的属性和方法。
     2）降低代码的灵活性。字类必须有父类的属性和方法，让子类多了很多的约束。
     3）增强了耦合性。父类常量，变量和方法修改时需要考虑字类的修改。有时会导致
     非常糟糕的结果，大段的代码可能需要重构。
     看完里氏替换原则让我对代码设计有了新的感悟，
     1）只要父类出现的地方字类就可以出现，而且替换成字类不会产生任何的错误。
     2）使用者根本就不需要知道是父类还是子类。
     现在有步枪，手枪，机枪三种类型的枪，他们都能够进行射击都能杀人。
     public abstract Class AbstractGAun{
        public abstract void shooot();
     }
     public HandGun extends AbstractGun{
        public void shoot(){
           System.out.println(.....手枪射击);
        }
     }
     public class Rifle extends Abstract AbstractGun{
        public void shoot (){
           System.out.pintln('''''步枪射击);
        }
     }
     public class Slodier{
        private AbstractGun;
        publci void setGun(AbstractGun gun){
         this.gun= gun;
        }
        publci void killEnemy(){
         
           System.out.pintln(士兵开始杀敌人);
           gun.shoot();
        }
     }
     public class client{
        public static void main(){
           Solider zhangasn = new Solider();
           sam.setGun(new Rifle);
        }
     }
     如果增加一个玩具枪的话
     publci class ToyGun extends AbstractGun{
        public void shoot{
           //玩具枪不能射击
        }
     }
     public class Client {
        publci static void main(String[]args){
         Solider zhangsan = new Solider();
         zhangsan.setgun(new ToyGun);
        } 
     }
     此时会有问题，玩具枪不能射击，所以应该让我玩具枪断开继承
     public abstract class AbstractToy{
        public void play;
     }
     publc class ToyGun extends AbstractToyGun{
         public vodi play{
            System.out.println(jjust to play);
         }
     }

     5 weeeks:
     java泛型德核心概念：
      告诉编译器想使用什么类型，然后编译器帮你处理细节
      泛型的主要目的：
      制定容器要持有什么类型对象，而且由编译器来保证类型的正确性。
      简单而安全的创建复杂模型

   原始类型
   原始类型就是泛型类型擦除了泛型信息后，在字节码中真正的类型。
   无论何时定义一个泛型类型，
   相应的原始类型都会被自动提供。原始类型的名字就是删去类型参数后的泛型类型的类
   名。擦除类型变量，并替换为限定类型（T为无限定的类型变量，用Object替换）。
   
   6 weeks:
      1.异常机制：
      1)异常类
      所有异常类都有一个共同的父类Throwable,
      Throwable 类有两个主要参数，一个是message,表示异常消息，另一个是cause
      表示触发该异常的其他异常。异常可以形成一个异常链，上层异常由底层异常触发，
      2）异常体系：
      以Throwable为根，Throwable 是所有异常的基类，它有两个子类：error,Exception
      ,error 表示系统错误或资源耗尽，由java系统自己使用，应用程序不抛出和进行处理，
      Exception表示应用程序错误，他有很多字类，应用程序也可以通过继承Exception
      或其他子类创建自定义异常。
      3）RuntimeException 比较特殊，它表示未受检的异常，Exception和其字类表示受检
      异常，受检和未受检的区别在于java如何处理这两种异常。对于受检异常，java会强制要求
      程序员进行处理，否则会编译有误。
      常见的RunTimeException:NullPointException ,IllegalStateException非法状态
      ClassCastException 非法强制类型转换错误。
      4）如此多的不同的异常基类其实并没有比Throwable这个基类多多少属性和方法，大部分在继承
      父类后只是定义了几构造方法。定义那么多不同的类的原因是为了名字不同，在抛出和捕获异常时，
      有助于代码的可读性和维护性

      5）自定义异常：除了javaAPI 中定义的异常类，也可以自己定义异常类，一般时继承Exception
      或者某个他的子类。如果父类时RunTimeException 或它得某个子类，则自定义异常也是未受检异常。
      public class AppException extends Exception {
         public AppException(){
            super();
         }
         public AppException(String message ,Throwable cause){
            super(message,cause)
         }
         public AppException(Throwable cause){
            super(cause)
         }
      }
      自定义异常和其他异常类一样，没有定义额外得属性和代码，只是定义了Exception,定义了构造方法并
      调用了父类得构造方法。

      2 异常处理;
      1）异常处理机制将根据抛出异常类型找第一个匹配的catch块代码，抛出的异常类型是catch
      中声明异常子类，e.getMessage()获取异常消息，e.printStackTrace()打印异常栈到
      标准错误输出流
      2）异常机制中还要一个重要的部分就是finally，catch 后面还可以跟finally
      finally内的代码不管有无异常发生都会执行，finally一般用于资源的释放，数据库连接，文件流。
      finally执行有一个细节，在try 或者catch 语句内有return语句则return语句在finally语句执行结束后
      才执行但是finally并不改变finally返回值
      3）throws跟在方法的后面可以声明多个异常用逗号隔开，声明的含义表示这个方法可能抛出异常
      ，且没有对这个异常进行处理，调用者必须进行处理，这个声明没有说明具体什么会抛出什么异常，
      如歌一个方法内调用了另一个声明抛出的受检异常的方法，则必须处理这些受检异常，处理方式既可以
      是catch 也可以继续使用throws

      完全解耦：
      
      7weeks:
      持有对象：
      如果一个程序只包含固定数量的且生命周期都是已知的对象，那么这是一个非常简单的程序。
      程序总是根据运行时才知道某些条件去创建对象，在此之前，不会排队规则来确定对象产生的顺序。
      2)Map:一组成对的键值对对象，允许你用键值来查找。映射表允许我们使用另一个对象来查找
      某个对象，它也被称为关联数组，因为它将某些对象与另外一些对象关联在一起
      Collection接口提供了序列的概念，一种存放一种对象的方式在

      知道所需对象的数量。
      需要在任意时刻任意位置创建任意数量的对象，所以就不能依靠命名引用来持有每一个对象。

      JAVA容器类库用途时保存对象，并将其划分为两个不同的概念：
      1。Collection:一个独立元素的序列，这些元素都服从一个或多个规则，List必须按照插入的顺序保存元素，
      而Set不能有重复的元素。

      接口：一个接口表示所有实现了该接口的类都像这样，任何使用某些特定接口的代码都可以知道调用接口的哪些方法，
      接口被用力啊建立类与类之间的协议

      8weeks:
        函数调用的基本原理：
        程序执行的基本原理:CPU有个指令指示器，指向下一条执行的指令，要么顺序执行，要么跳转。
        程序从main函数开始顺序执行，函数调用可以看可以看作无条件跳转。碰到retun语句或者函数结尾的时候
        再执行一次函数无条件跳转，跳转回调用方，执行调用函数后的下一条指令。
        装饰器模式：
        装饰器模式使用分层对象来动态透明的向单个对象中添加责任，装饰器指定包装在
        对象周围所有的对象都具有相同的基本接口，有些事务是可装饰的，可以通过将其他类
       包装在这个对象周围，将功能分层，无论对象是否被装饰你都拥有一个向对象发送的公共消息集，
       装饰类也可以添加新方法。
       装饰器通过使用组合和形式的化结构来实现的。
       装饰器demo:
         class Basic{
            private String value;
            public void set(String va1){
               value = val;
            }
            public String get(Value val){
            return value;
            }

         class Decorator extends Basic{
            protected Basic basic;
            public Decorator (Basic basic){
               this.basic = basic;
            }
            public String get(){
               return basic.get();
            }

            public void set(String val){
               basic.set(val);
            }

         class TimeStamped{
            private final long timeStamp;
            public TimeStamped (Basic basic){
               super(basic);
               timeStamp = new Date().getTime();
            }
            public long getStamp(){
               return timeStamp;
            }

            class SerialNumered extends Decorator{
               private static long counter =1;
               private final long serialNumber counter++;
               public SerialNubered(Basic basic){
                  super(basic);
                  public long gerSerialNumber(){
                     return serialNumber;
                  }
                  public class Decoration {
                     public static void main(String []args){
                        TimeStamped timp = new TimeStamped(new Basic());
                        TimeStamped timpq = new TimeStamped( new TimeStamped(new Basic()));
                     }
                  }
               }
            }
         }
         }

         }

      8 month:
         设计模式学习：
      1.接口的隔离原则定义：
      接口分为两种 ：实例接口，实例接口在java中声明一个类，然后用new关键字产生一个实例
      它是对一个类型事务的描述，这是一种接口，例如Person person =new Person(),产生一个实例，这实例
      要遵从的标准就是Person这个类，person类就是zhangsan接口。
      2.类接口，java中经常使用的interface关键字定义的接口。
      隔离性的定义：Clients should not be forced to depend upon interface that that they don't use。
      3.类间的关系应该建立在最小的接口上。
      客户端不应该依赖它不需要接口


      拓展:Spring框架的学习
      Spring最核心的是IOC
      IOC容器最主要为了完成对象的创建和依赖管理的注入，就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。
      Spring的创建是典型的工厂模式，这一系列的Bean工厂，也即IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务。

      java类加载机制：
      java虚拟机把描述类的数据从class加载到内存,并对数据进行校验
      转换解析和初始化最终可以被虚拟机直接使用的java类型Class文件由类装载器装载后，在JVM中将形成一份描述Class结构的元信息对象，通过该元信息对象可以获知Class的结构信息：如构造函数，属性和方法等，Java允许用户借由这个Class相关的元信息对象间接调用Class对象的功能,这里就是我们经常能见到的Class类。
      类装载器就是寻找类的字节码文件并构造出类在JVM内部表示的对象组件。在Java中，类装载器把一个类装入JVM中，要经过以下步骤：
      
      java反射：
      反射就是获取类的字节码文件，对于任何一个类我们都知道有那些方法和属性。对于一个对象我们都能够对他的方法和属性进行调用，
      我们把这种动态获取对象信息和调用的方法功能称为反射。
      反射通过加载字节码文件创建class对象，类的装载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，
      用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
      类的初始化顺序：
       1.类从顶至底的顺序初始化，所以声明在顶部的字段的早于底部的字段初始化
       2.超类早于子类和衍生类的初始化
       3.如果类的初始化是由于访问静态域而触发，那么只有声明静态域的类才被初始化，而不会触发超类的初始化或者子类的4.初始化即使静态域被子类或子接口或者它的实现类所引用。
       5.接口初始化不会导致父接口的初始化。
       6.静态域的初始化是在类的静态初始化期间，非静态域的初始化时在类的实例创建期间。这意味这静态域初始化在非静态域之前。
       7.非静态域通过构造器初始化，子类在做任何初始化之前构造器会隐含地调用父类的构造器，他保证了非静态或实例变量（父类）初始化早于子类

       加载.class文件方式：
       1). 从本地系统中直接加载 
       2). 通过网络下载.class文件 
       3). 从zip，jar等归档文件中加载.class文件 
       4). 从专有数据库中提取.class文件 
       5). 将Java源文件动态编译为.class文件
       泛型：
       泛型出现的一个原因就是为了创造容器，容器就是要存放对象所使用的地方，所有程序在运行时都要求你持有一大堆对象
       容器算的上最具有重用性的类库之一。
       public class Automobile
         {
            private Automobile a;
            public Continer(Automobile a){
               this.a=a;
            }
            Automobile get(){
               return a;
            }
         public class Holder {
            private Object a;
            public Holder2(Object a){
               this.a =a;

            }
         public staic void main(String []args){

         }
         }
         与其使用Object我们更喜欢暂时不指定类型
         public class Holder3<T>{
            private T a;
            public Holder3(T a){
               this.a =a;
            }
            public void set(T a){
               this.a =a;
               }
            public T get(){
               return a;
            }
         public staic void main(Stirng []args){
               Holder3<Automible> h3 = new  Holder3<Automible>();
               Auttomible a =h3.get()
         }

         }



      类型信息：
      运行时类型信息使得我们可以在程序运行时发现和使用类型信息
      面向对象编程中的目的是：让代码只操作基类的引用，如果添加一个新类来扩展
      程序，就不会影响到原来的代码
      

      
      Spring cloud学习：
      Nigx:是一款轻量级服务器，反向代理服务器，由于他内存占用极小，所以启动极快，高并发能力强
      什么是反向代理：理解一下正向代理
      张三请求李四向王二借钱，王二把钱借给李四，但是不知道是张三借的
      这个过程是一个正向代理的过程：它隐藏了真实的客户端，服务端不知道真实的客户端，客户端的请求都被代理服务器
      例如：直接访问谷歌www.google.com肯定会被残忍block，于是你可以在国外搭建一台服务器，让代理去请求谷歌，
      然后再把请求结果返回给客户端
      反向代理：例如打10086的时候你永远不会去关心电话那头是男还是女高矮胖瘦，真正关心得是字节问题能不能得到解决，电话
      那头总会有人给你解决
      同样当我们请求谷歌时背后有成千上万台服务器，我们不需要关心请求了哪一台，我们只需要知道反向代理服务器是谁就可以了
      反向代理服务器会帮我们把请求转发给真实服务器，Nigx就是性能非常好得反向代理服务器
      正向代理和反向代理得区别：
      正向代理的对象是客户端，反向代理的对象是服务端
      反向代理的实现：1）需有一个负载均衡的设备分发用户的请求，将用户请求分发到空闲的服务器上
      2）服务器返回自己的服务到负载均衡
      3）负载均衡将自己的服务返回给客户端，
      这也就意味着用户做服务器域名解析时解析得到的IP是负载均衡的IP，这样的好处就是当新加入或移走服务器时仅需要
      修改负载均衡的服务器列表而不会影响现有的服务
      

      Spring cloud是一系列框架的有序集合，利用Spring boot开发的便利性简化了分布式系统的基础设施的开发
      1.服务注册于发现：随着业务发展，单一系统越来越复杂，用户量上升，提升服务器的性能终会有瓶颈，
      可以通过分布式技术，建立服务集群，水平业务划分、应用分解、系统分流微服务架构来解决系统性能的问题和
      复杂业务问题。
      Lazy:服务注册与发现
      



      
