1st weeks:
   一、对象的导论
   1.抽象的过程：我们所能够解决问题的复杂性取决于抽象的类型和质量。
   抽象的类型：是指抽象的是什么。

   2.面向对象语言的五个特征：
   1） 万物皆对象、程序是对象的集合他们通过发送消息彼此相关联
   2）每个对象都具有自己的由其他对象所构成的所构成的存储、
   3）每个对象都拥有其类型、
   4）某一特定类型的所有对象都可以接受同样的消息

   2.1面向对象五个原则
   单一职责院子
   依赖倒置

   我所理解的面向对象是继承、封装、多态这三大特征、不知道书中为什么列出的是这五大特征，
我想等以后编码水平提高了才能进一步理解书中的这几句话吧。

   3.复用的具体实现：
   1）最简单的复用某个类的方式是直接使用类的一个对象，将一个类的对象置于一个新的类中，
   被称之为创建"成员对象"
   2）任意类型的其他对象组合成新类想要的功能被称之为组合，如果组合是
   动态发生的，我们称之为"聚合"。组合是 has-a的关系
   3）组合中新类成员中的成员对象通常被声明为private

   4.继承：当创建完一个新类的时候，即使另一个新类与其具有相同的功能，还是创建一个新的类，
   以现有类为基础复制他、然后通过添加和修改这个副本来创建新的类
   类型不仅仅是描述作用一个对象集合的约束条件、同时还有与其他类型之间的关系。
   两个类型可以有相同的特性和行为，其中一个类型可能比另一个含有更多特性。
   继承使用基类和导出类的概念表示了这种类型之间的相似性。
   一个基类包含导出类的所共享的特性和行为。

   5.单根继承：
   在单根继承结构中的所有对象都具有一个公共接口，他们归根到底都是相同的基本类型。
   单根继承保证所有对象都具有某些功能。

   二、一切都是对象
   1.用引用操作对象
   操作标识符实际上是一个对象的引用，引用和对象的关系就如电视和遥控器的关系。
   String s 这里只是引用不是对象。
   一单创建一个引用就希望他与一个新的对象相关联，用关键字new来实现与新的对象相关联。
   
   2.存储到什么地方
   1）寄存器：是最快的存储区域位于处理器的内部，无法进行操控
   2）堆栈：位于Ram中，若堆栈的指针向下移动分配新的内存，向上移动则释放内存，对象的引用
   存储在堆栈当中。
   3)当需要一个对象时。用new写一行简单的代码执行代码会自动在堆里分配内存。
   4）常量存储：常量值通常存放在代码内部，这样做是安全的因为他永远不会改变，可以选择将
   常量存储在rom中
    
   2 weeks:
      1.接口的本质：
      对象可以看作是某种数据类型，但是并不能反映出对象以及操作对象的本质。
      我们实际关心的不是对象的类型，而是对象的能力。
      比如：计算一组数字 我们不关心是用计算器计算还是算盘，关心的是对象计算的能力。

      1）所以类型并不重要，重要的是能力，接口就可以用来表示能力。

      2）接口声明了一组能力，但自身并没有实现这个能力，它只是作为一种约定。

      3）接口涉及交互两方对象，一方需要实现这个接口，另一方需要使用这个接口，对象之间
      并不互相依赖，它们只是通过接口进行交互。

      4）类实现接口，表示类的对象具有接口所表示的能力。

      5）接口重要的地方在于它降低了耦合提高了灵活性。使用接口的代码依赖的是接口本身，而非接口的具体类型。
      程序完全可以根据情况替换接口的实现，而不影响接口使用者，
      6)解决复杂问题的关键是分而治之，将复杂的大问题分解为小问题，分解的核心就是要降低耦合。
       
      2.接口的细节
      1）接口中可以定义变量，例如：
      public interface Interface1{
         public static final int a = 0;
      }
      变量可以通过接口名 Interface1.a来使用

      2）接口也可以继承
      与类不同的是，接口可以有多个父接口

      总结：针对接口不仅可以复用代码也可以降低耦合提高代码的灵活性

      3.抽象类
      1）抽象是相对于具体而言，具体类有直接相应的对象，而抽象类没有。
      2）抽象方法也只有声明并没有实现
      3）抽象类不能创建对象，要创建对象必须使用它的具体字类。
      例如：
     Shape shape = new Circle();
     Shape 是类型Shape类型的变量，引用了具体字类Circle的对象。

     4.为什么需要抽象类
     1）在编写程序时每个人都可能会犯错，减少错误不能依赖个人的优秀素质
     还需要一些机制，使得一个普通人都把容易得事做对，而难以把事情做错。
     抽象类引导使用者正确使用它们，减少误用，使用抽象方法而非空方法体。
     使用抽象类，类的使用者创建对象的时候必须要使用某个具体的字类，而不可能误用不完整的父类。


     5.设计模式
     1.工厂模式
     在任何需要生成复杂对象的地方，都可以使用工厂模式。一个调用者想知道对象
     只要知道名称就可以了，如果想增加一个产品，只要扩展一个工厂类就可以了，
     屏蔽具体实现，调用者只关心产品接口
     2.抽象工厂模式
     在一个产品族里面定义多个产品，在一个工厂里聚合多个同类产品

     3 weeks:
     1.JAVA中的多重继承
     1）接口不仅仅是一种更纯粹的抽象类，它的目标比这个要更高，接口是没有任何具体实现的，
     没有与任何接口相关的存储，也就无法阻止多个接口的组合，组合多个类的接口行为被
     称作为多重继承，
     2）通过继承里扩展接口
     2.通过继承来扩展接口
     通过继承可以很容易地在接口中添加新的方法声明，还可以通过继承在新的接口中组合
     数个接口。
     interface Monster{
        void meance();
     }
     interface dangerousMonster extends Monster{
        void destory();
     }
     interface Lehal{
        void kill ();
     }
     class DragonZilla implements DangerousMonster{
        public void meance(){

        }
        public void destory{

        }
     }
     3.适配接口
     1）接口最吸引人的原因之一就是允许同一个接口具有多个不同的具体实现
     可以用任何你想要的对象来调用我的方法，只要你的对象调用我的接口。”
     2）java中接口的适配模式
     当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，
     因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题
     ，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，
     实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，
     所以我们写一个类，继承该抽象类，重写我们需要的方法就行

     4）接口与工厂
     接口是实现多重继承的途径，而生成遵循某个接口的对象的典型方式就是工厂方法
     设计模式
      4 weeks:
     面向对象五大原则
     1.单一职责原则
     最近写代码发现，虽然功能实现了，但是代码的设计是一团糟，耦合性特别强，
     有太多冗余的代码，结构也不够清晰，于是就研读一下设计模式，研读设计模式之前，
     开篇先讲了面向对象五大原则，看完之后，也深有感悟。
     单一原则的定义是：应该有且只有一个原因引起类的变更。
     单一职责原则的好处：
     1）可以降低类的复杂性，实现什么职责都有清洗明确的定义。
     2）增加了代码的可读性，更加容易维护
     3）变更引起的风险降低，如果一个接口的单一职责做得好，一个接口只对响应的
     实现类有影响，这对系统的扩展性，维护性都有很大帮助。
     总结：单一职责原则提出了一个编写代程序的标准，来衡量接口或类设计的是否优良。
     所以在代码设计的时候，接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化。

     2里氏替换原则
     一般优秀的语言机制有如下的特点：
     1）代码共享，减少创建类的工作量，每个字类都有父类的方法和属性。
     2）提高代码的重用性
     3）提高代码的可扩展性
     4)提高代产品或项目的开放性
     继承的缺点给我最大的感受就是：
     1）继承有很大的侵入性，只要继承就必须有父类的属性和方法。
     2）降低代码的灵活性。字类必须有父类的属性和方法，让子类多了很多的约束。
     3）增强了耦合性。父类常量，变量和方法修改时需要考虑字类的修改。有时会导致
     非常糟糕的结果，大段的代码可能需要重构。
     看完里氏替换原则让我对代码设计有了新的感悟，
     1）只要父类出现的地方字类就可以出现，而且替换成字类不会产生任何的错误。
     2）使用者根本就不需要知道是父类还是子类。
     现在有步枪，手枪，机枪三种类型的枪，他们都能够进行射击都能杀人。
     public abstract Class AbstractGAun{
        public abstract void shooot();
     }
     public HandGun extends AbstractGun{
        public void shoot(){
           System.out.println(.....手枪射击);
        }
     }
     public class Rifle extends Abstract AbstractGun{
        public void shoot (){
           System.out.pintln('''''步枪射击);
        }
     }
     public class Slodier{
        private AbstractGun;
        publci void setGun(AbstractGun gun){
         this.gun= gun;
        }
        publci void killEnemy(){
         
           System.out.pintln(士兵开始杀敌人);
           gun.shoot();
        }
     }
     public class client{
        public static void main(){
           Solider zhangasn = new Solider();
           sam.setGun(new Rifle);
        }
     }
     如果增加一个玩具枪的话
     publci class ToyGun extends AbstractGun{
        public void shoot{
           //玩具枪不能射击
        }
     }
     public class Client {
        publci static void main(String[]args){
         Solider zhangsan = new Solider();
         zhangsan.setgun(new ToyGun);
        } 
     }
     此时会有问题，玩具枪不能射击，所以应该让我玩具枪断开继承
     public abstract class AbstractToy{
        public void play;
     }
     publc class ToyGun extends AbstractToyGun{
         public vodi play{
            System.out.println(jjust to play);
         }
     }

     5 weeeks:
     java泛型德核心概念：
      告诉编译器想使用什么类型，然后编译器帮你处理细节
      泛型的主要目的：
      制定容器要持有什么类型对象，而且由编译器来保证类型的正确性。
      简单而安全的创建复杂模型

   原始类型
   原始类型就是泛型类型擦除了泛型信息后，在字节码中真正的类型。
   无论何时定义一个泛型类型，
   相应的原始类型都会被自动提供。原始类型的名字就是删去类型参数后的泛型类型的类
   名。擦除类型变量，并替换为限定类型（T为无限定的类型变量，用Object替换）。





      
